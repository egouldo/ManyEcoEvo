% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/standardise_response.R
\name{process_analyst_data}
\alias{process_analyst_data}
\alias{standardise_response}
\alias{process_response}
\alias{log_transform_response}
\title{Process Response Data for Meta-Analysis}
\usage{
standardise_response(
  dat,
  estimate_type = character(1L),
  param_table = NULL,
  dataset = character(1L)
)

process_response(dat, ...)

log_transform_response(dat, sim = 10000L, ...)
}
\arguments{
\item{dat}{A tibble of analyst data with a list-column called}

\item{estimate_type}{The type of estimate to be standardised. Character vector of length 1, whose value may be "Zr", "yi", "y25", "y50", "y75".}

\item{param_table}{A table of estimated 'population' parameters for each variable in the analysis datasets.}

\item{dataset}{One of either "blue tit" or "eucalyptus"}

\item{sim}{a numeric vector of length 1L with the number of simulations that should be passed to \code{\link[=log_transform]{log_transform()}}}
}
\value{
A tibble of analyst data with standardised values contained in a list-column called 'back_transformed_data'
}
\description{
This function generates the response data for meta-analysis without standardising the effect sizes / out-of-sample predictions.
}
\section{Functions}{
\itemize{
\item \code{standardise_response()}: Standardise response data for meta-analysis

\item \code{process_response()}: Process response data for meta-analysis but do not standardise effect-sizes

\item \code{log_transform_response()}: Standardise response data for meta-analysis

}}
\section{\code{standardise_response()}}{
When the \code{estimate_type} is \code{"Zr"}, \code{\link[=standardise_response]{standardise_response()}} standardises
effect-sizes with \code{\link[=est_to_zr]{est_to_zr()}}, assuming that the \code{beta_estimate} and
\code{beta_SE} values have already been back-transformed to the appropriate scale. #TODO check this.

When the \code{estimate-type} is \code{"yi"} or otherwise, the function:
\enumerate{
\item assigns a \code{transformation_type} with \code{\link[=assign_transformation_type]{assign_transformation_type()}},
assumes that
\item Converts the out-of-sample predictions on the link- or transformed-response
scale back to the original response scale using \code{\link[=convert_predictions]{convert_predictions()}}.
\item Standardises predictions on the original response-scale to the Z-scale, with \code{\link[=pred_to_Z]{pred_to_Z()}}.
}

Note that for $y_i$ or out of sample predictions that are standardised,
if param_table is \code{NA} or \code{NULL} for a given variable, then the response
variable will not be standardised, and NA will be returned for that entry in \code{back_transformed_data}.
}

\section{\code{process_response()}}{
Formats tibbles in the list-column \code{back_transformed_data} to ensure that the
correct columns are present for meta-analysis, matching the outputs of
\code{\link[=standardise_response]{standardise_response()}}. For blue tit data \code{dat$back_transformed_data$fit}
and for eucalyptus data, \code{dat$back_transformed_data$estimate} is renamed \code{Z}.
\code{se.fit} is renamed \code{VZ}.
}

\section{\code{\link[=log_transform_response]{log_transform_response()}}}{
maps \code{\link[=log_transform_yi]{log_transform_yi()}} onto back-transformed data stored in list-columns within \link{dat}
}

\examples{
ManyEcoEvo_yi \%>\% 
filter(dataset == "eucalyptus") \%>\% 
  pluck("data", 1) \%>\% 
  back_transform_response_vars_yi("yi", "eucalyptus") \%>\% 
  log_transform_response()
}
\seealso{
\code{\link[=est_to_zr]{est_to_zr()}},  \code{\link[=assign_transformation_type]{assign_transformation_type()}}

Other analyst-data: 
\code{\link{back_transform_response_vars_yi}()}

Other analyst-data: 
\code{\link{back_transform_response_vars_yi}()}
}
\concept{analyst-data}
