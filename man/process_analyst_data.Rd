% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/standardise_response.R
\name{process_analyst_data}
\alias{process_analyst_data}
\alias{standardise_response}
\alias{process_response}
\alias{log_transform_response}
\title{Process Response Data for Meta-Analysis}
\usage{
standardise_response(
  data,
  estimate_type = character(1L),
  param_table = NULL,
  dataset = character(1L),
  ...
)

process_response(data, ...)

log_transform_response(data, sim = 10000L, ...)
}
\arguments{
\item{data}{A tibble of analyst data with a list-column called}

\item{estimate_type}{The type of estimate to be standardised. Character vector of length 1, whose value may be "Zr", "yi", "y25", "y50", "y75".}

\item{param_table}{A table of estimated 'population' parameters for each variable in the analysis datasets.}

\item{dataset}{Character vector of length 1. The name of the dataset being processed, e.g. \verb{blue tit} or \code{eucalyptus}.}

\item{...}{Ignored}

\item{sim}{a numeric vector of length 1L with the number of simulations that should be passed to \code{\link[=log_transform]{log_transform()}}}
}
\value{
A tibble of analyst data with standardised values contained in a list-column called 'back_transformed_data'
}
\description{
This is a family of functions that process response data for meta-analysis, either standardising effect sizes / out-of-sample predictions, or simply formatting the data for meta-analysis without standardisation or transformation.
}
\section{Functions}{
\itemize{
\item \code{standardise_response()}: Standardise response data for meta-analysis

\item \code{process_response()}: Process response data for meta-analysis but do not standardise effect-sizes

\item \code{log_transform_response()}: Standardise response data for meta-analysis

}}
\section{\code{standardise_response()}}{
When the \code{estimate_type} is \code{"Zr"}, \code{standardise_response()} standardises
effect-sizes with \code{\link[=est_to_zr]{est_to_zr()}}, assuming that the \code{beta_estimate} and
\code{beta_SE} values have already been back-transformed to the appropriate scale. #TODO check this.

When the \code{estimate-type} is \code{"yi"} or otherwise, the function:
\enumerate{
\item assigns a \code{transformation_type} with \code{\link[=assign_transformation_type]{assign_transformation_type()}},
assumes that
\item Converts the out-of-sample predictions on the link- or transformed-response
scale back to the original response scale using \code{\link[=convert_predictions]{convert_predictions()}}.
\item Standardises predictions on the original response-scale to the Z-scale, with \code{\link[=pred_to_Z]{pred_to_Z()}}.
}

Note that for $y_i$ or out of sample predictions that are standardised,
if param_table is \code{NA} or \code{NULL} for a given variable, then the response
variable will not be standardised, and NA will be returned for that entry in \code{back_transformed_data}.
}

\section{\code{process_response()}}{
Formats tibbles in the list-column \code{back_transformed_data} to ensure that the
correct columns are present for meta-analysis, matching the outputs of
\code{\link[=standardise_response]{standardise_response()}}. For blue tit data \code{data$back_transformed_data$fit}
and for eucalyptus data, \code{data$back_transformed_data$estimate} is renamed \code{Z}.
\code{se.fit} is renamed \code{VZ}.
}

\section{log_transform_response()}{
maps \code{\link[=log_transform_yi]{log_transform_yi()}} onto back-transformed data stored in list-columns within \code{data}
}

\examples{
# Standardise effect-sizes for eucalyptus dataset

data(ManyEcoEvo)
ManyEcoEvo \%>\%
 filter(dataset == "eucalyptus") \%>\%
 pluck("data", 1) \%>\%
 standardise_response(estimate_type = "Zr", 
                      param_table =  NULL,
                      dataset =  "eucalyptus")
data(ManyEcoEvo_yi)
ManyEcoEvo_yi \%>\%
filter(dataset == "eucalyptus") \%>\%
  pluck("data", 1) \%>\%
  back_transform_response_vars_yi() \%>\%
  log_transform_response()
}
