#' Apply VZ exclusion to a data-frame containing list-columns of yi subsets
#'
#' @param df A dataframe of yi data subsets generated by [generate_yi_subsets()] or [split_yi_subsets()].
#' @param VZ_cutoff A numeric vector of length 1, values equal to or greater than this value of VZ will be filtered out of the dataframes stored in `df`'s list-column `data`, else a named list of numeric values, where the names are the dataset names and the values are the `VZ_cutoff`s for each `dataset` in `df`.
#' @param VZ_colname Either A character vector of length 1, the name of the column in the dataframes stored in `df`'s list-column `data` that contains the VZ values. Or else a named list of character values, where the names are the dataset names and the values are the `VZ_colname`s  for each `dataset` in `df`.
#' @return A dataframe of yi subsets, whose extreme values of VZ have been removed.
#' @export
#' @import dplyr
#' @importFrom purrr map map2
#' @importFrom pointblank col_exists
#' @importFrom cli cli_alert_warning
#' @seealso Applies [exclude_extreme_VZ()] to each dataframe in the list-column `data` of `df`.
#' @family Multi-dataset Wrapper Functions
#' @details
#' `df` must contain the columns `"data"`, `"diversity_data"` and `"dataset"`.
#' If only one value of `VZ_colname` and `VZ_cutoff` is supplied, it will be recycled to match the number of datasets in `df`.
#' 
#' If a named list is supplied for `VZ_colname` and `VZ_cutoff`, the names must match the dataset names in `df`.
#' @examples
#' data(ManyEcoEvo_yi)
#' ManyEcoEvo_yi %>%
#'   prepare_response_variables(
#'     estimate_type = "yi",
#'     param_table =
#'       ManyEcoEvo:::analysis_data_param_tables,
#'     dataset_standardise = "blue tit",
#'     dataset_log_transform = "eucalyptus") %>%
#'   generate_yi_subsets() %>% 
#'   apply_VZ_exclusions(VZ_colname = 
#'                         list("eucalyptus" = "se_log", 
#'                              "blue tit" = "VZ"), 
#'                       VZ_cutoff = 3)
apply_VZ_exclusions <- function(df = data.frame(), VZ_colname, VZ_cutoff) {
  # ---- Argument Checking -----
  pointblank::col_exists(df, columns = c("data", "diversity_data", "dataset"))
  
  if (!is.null(names(VZ_colname))) {
    pointblank::expect_col_vals_make_set(object = df, 
                                         columns = dataset, 
                                         set = names(VZ_colname))
  }
  
  if (!is.null(names(VZ_cutoff))) {
    pointblank::expect_col_vals_make_set(object = df, 
                                         columns = dataset, 
                                         set = names(VZ_cutoff))
  }
  
  cli::cli_h1("Applying VZ exclusions")
  
  if (is.list(VZ_colname)) {
    map(VZ_colname, ~ {
      stopifnot(
        is.character(.x)
      )
    })
  } else {
    stopifnot(
      is.character(VZ_colname)
    )
    # ----- Format VZ exclusions when VZ_colname is not list -----
    if (length(VZ_colname) < length(unique(df$dataset))) {
      cli::cli_alert_warning("{.arg VZ_colname} = {.val {VZ_cutoff}} was recycled to match the number of unique datasets in {.arg df}.")
      VZ_colname <- rep(VZ_colname, length(unique(df$dataset)))
    }
  }
  
  if (is.list(VZ_cutoff)) {
    map(VZ_cutoff, ~ {
      stopifnot(
        is.numeric(.x)
      )
    })
  } else {
    stopifnot(
      is.numeric(VZ_cutoff)
    )
    # ----- Format VZ exclusions when VZ_cutoff is not list -----
    if (length(VZ_cutoff) < length(unique(df$dataset))) {
      cli::cli_alert_warning("{.arg VZ_cutoff} = {.val {VZ_cutoff}} was recycled to match the number of unique datasets in {.arg df}.")
      VZ_cutoff <- rep(VZ_cutoff, length(unique(df$dataset)))
    }
  }
  
  # ----- Create formulas for matching VZ_cutoff and VZ_colname to df$dataset -----
  
  if (is.list(VZ_colname)) {
    formulae_match_VZ_colname <- map2(names(VZ_colname), 
                                      VZ_colname, 
                                      rlang::new_formula)
  } else {
    formulae_match_VZ_colname <- map2(unique(df$dataset), 
                                      VZ_colname, 
                                      rlang::new_formula)
  }
  
  if (is.list(VZ_cutoff)) {
    formulae_match_VZ_cutoff <- map2(names(VZ_cutoff), 
                                     VZ_cutoff, 
                                     rlang::new_formula)
  } else {
    formulae_match_VZ_cutoff <- map2(unique(df$dataset), 
                                     VZ_cutoff, 
                                     rlang::new_formula)
  }
  
  # ----- Apply VZ exclusions -----
  df_out <- df %>%
    ungroup() %>% 
    mutate(
      VZ_colname_val = case_match(dataset,
                                  !!!formulae_match_VZ_colname,
                                  .default = NA), 
      VZ_cutoff_val = case_match(dataset,
                                 !!!formulae_match_VZ_cutoff,
                                 .default = NA),
      data = pmap( # TODO check whether we should run on effects_analysis instead of data
        list(data, VZ_colname_val, VZ_cutoff_val),
        ~ exclude_extreme_VZ(df = ..1, VZ_colname = ..2, VZ_cutoff = ..3)
      ),
      diversity_data = map2(
        .x = diversity_data,
        .y = data,
        .f = ~ semi_join(.x, .y, by = "id_col")
      )
    ) %>% 
    select(-VZ_colname_val, -VZ_cutoff_val)
  
  return(df_out)
}
